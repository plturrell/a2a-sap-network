<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>A2A Portal - Performance Tests</title>
    <script src="../../resources/sap-ui-core.js"
        data-sap-ui-theme="sap_horizon"
        data-sap-ui-libs="sap.m,sap.ui.core,sap.f,sap.tnt"
        data-sap-ui-resourceroots='{
            "com.sap.a2a.portal": "../../",
            "test": "../"
        }'
        data-sap-ui-animation="false">
    </script>
    <link rel="stylesheet" type="text/css" href="../../resources/sap/ui/thirdparty/qunit.css">
    <script src="../../resources/sap/ui/thirdparty/qunit.js"></script>
    <script src="../../resources/sap/ui/qunit/qunit-junit.js"></script>
    <script src="../../resources/sap/ui/qunit/qunit-coverage.js"></script>
    
    <style>
        /* Performance test styles */
        .performance-test-container {
            padding: 20px;
            background: white;
        }
        
        .large-dataset-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .performance-metrics {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 9999;
        }
    </style>
</head>
<body class="sapUiBody">
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
    
    <!-- Performance metrics display -->
    <div id="performance-metrics" class="performance-metrics" style="display: none;">
        <div id="fps-counter">FPS: --</div>
        <div id="memory-usage">Memory: --</div>
        <div id="render-time">Render: --ms</div>
    </div>
    
    <!-- Test content container -->
    <div id="performance-test-content" class="performance-test-container" style="display: none;">
        <div id="test-component-container"></div>
        <div id="large-dataset-container" class="large-dataset-container"></div>
    </div>

    <script>
        sap.ui.require([
            "test/performance/PerformanceTestSuite",
            "sap/ui/core/mvc/XMLView",
            "sap/m/Button",
            "sap/m/Input",
            "sap/m/List",
            "sap/m/StandardListItem",
            "sap/ui/model/json/JSONModel"
        ], function(PerformanceTestSuite, XMLView, Button, Input, List, StandardListItem, JSONModel) {
            "use strict";

            QUnit.config.autostart = false;
            QUnit.config.testTimeout = 30000; // 30 seconds for performance tests

            // Performance monitoring utilities
            let performanceMonitor = {
                startTime: 0,
                frameCount: 0,
                lastFrameTime: 0,
                
                start: function() {
                    this.startTime = performance.now();
                    this.frameCount = 0;
                    this.lastFrameTime = this.startTime;
                    this.requestFrame();
                    document.getElementById('performance-metrics').style.display = 'block';
                },
                
                stop: function() {
                    document.getElementById('performance-metrics').style.display = 'none';
                },
                
                requestFrame: function() {
                    requestAnimationFrame(() => {
                        this.frameCount++;
                        const currentTime = performance.now();
                        
                        if (currentTime - this.lastFrameTime >= 1000) {
                            const fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastFrameTime));
                            document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
                            
                            if (performance.memory) {
                                const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                                document.getElementById('memory-usage').textContent = `Memory: ${memoryMB}MB`;
                            }
                            
                            this.frameCount = 0;
                            this.lastFrameTime = currentTime;
                        }
                        
                        this.requestFrame();
                    });
                }
            };

            // Test data generators
            function generateLargeDataset(size) {
                const data = [];
                for (let i = 0; i < size; i++) {
                    data.push({
                        id: i,
                        title: `Item ${i}`,
                        description: `This is a detailed description for item number ${i}. It contains some sample text to simulate real-world data.`,
                        value: Math.random() * 1000,
                        category: `Category ${Math.floor(i / 100)}`,
                        status: i % 2 === 0 ? 'Active' : 'Inactive',
                        lastModified: new Date(Date.now() - Math.random() * 1000000000).toISOString()
                    });
                }
                return data;
            }

            function createTestComponent(data) {
                return new Promise((resolve) => {
                    const model = new JSONModel(data);
                    const list = new List({
                        items: {
                            path: "/items",
                            template: new StandardListItem({
                                title: "{title}",
                                description: "{description}",
                                info: "{status}",
                                infoState: {
                                    path: "status",
                                    formatter: function(status) {
                                        return status === "Active" ? "Success" : "Warning";
                                    }
                                }
                            })
                        }
                    });
                    
                    list.setModel(model);
                    resolve(list);
                });
            }

            // Performance Tests
            QUnit.module("Application Startup Performance", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                    performanceMonitor.start();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                    performanceMonitor.stop();
                }
            });

            QUnit.test("Should measure application startup time", function(assert) {
                const done = assert.async();
                
                // Note: In real scenario, this would measure actual app startup
                // Here we simulate the measurement
                setTimeout(() => {
                    const mockStartupResult = {
                        coreInitTime: 800,
                        firstViewTime: 1200,
                        totalStartupTime: 2000,
                        passesThreshold: true,
                        threshold: 3000
                    };
                    
                    assert.ok(mockStartupResult.passesThreshold, "Startup time should be within acceptable limits");
                    assert.ok(mockStartupResult.totalStartupTime < mockStartupResult.threshold, 
                             `Total startup time (${mockStartupResult.totalStartupTime}ms) should be less than threshold (${mockStartupResult.threshold}ms)`);
                    
                    done();
                }, 100);
            });

            QUnit.module("View Rendering Performance", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                    performanceMonitor.start();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                    performanceMonitor.stop();
                }
            });

            QUnit.test("Should measure view rendering performance", function(assert) {
                const done = assert.async();
                
                const startTime = performance.now();
                
                // Create a complex view structure
                const data = { items: generateLargeDataset(100) };
                
                createTestComponent(data).then(component => {
                    const creationTime = performance.now();
                    
                    component.placeAt("qunit-fixture");
                    
                    component.addEventDelegate({
                        onAfterRendering: () => {
                            const renderTime = performance.now() - creationTime;
                            const totalTime = performance.now() - startTime;
                            
                            assert.ok(renderTime < 1000, `Rendering time (${Math.round(renderTime)}ms) should be under 1 second`);
                            assert.ok(totalTime < 1500, `Total time (${Math.round(totalTime)}ms) should be under 1.5 seconds`);
                            
                            component.destroy();
                            done();
                        }
                    });
                });
            });

            QUnit.test("Should handle large datasets efficiently", function(assert) {
                const done = assert.async();
                
                // Test with progressively larger datasets
                const dataSizes = [100, 500, 1000];
                let currentTest = 0;
                const results = [];
                
                function testNextDataSize() {
                    if (currentTest >= dataSizes.length) {
                        // Analyze results
                        const averageTimePerItem = results.map(r => r.time / r.size);
                        const hasLinearScaling = averageTimePerItem.every((time, index) => {
                            if (index === 0) return true;
                            return time <= averageTimePerItem[0] * 2; // Allow 2x degradation
                        });
                        
                        assert.ok(hasLinearScaling, "Rendering should scale roughly linearly with data size");
                        
                        console.log("Dataset Performance Results:", results);
                        done();
                        return;
                    }
                    
                    const size = dataSizes[currentTest];
                    const startTime = performance.now();
                    const data = { items: generateLargeDataset(size) };
                    
                    createTestComponent(data).then(component => {
                        component.placeAt("qunit-fixture");
                        
                        component.addEventDelegate({
                            onAfterRendering: () => {
                                const renderTime = performance.now() - startTime;
                                results.push({ size: size, time: renderTime });
                                
                                component.destroy();
                                currentTest++;
                                
                                // Small delay between tests
                                setTimeout(testNextDataSize, 100);
                            }
                        });
                    });
                }
                
                testNextDataSize();
            });

            QUnit.module("Data Binding Performance", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                    performanceMonitor.start();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                    performanceMonitor.stop();
                }
            });

            QUnit.test("Should measure data binding performance", function(assert) {
                const done = assert.async();
                
                this.oPerformanceEngine.testDataBindingPerformance({ 
                    items: generateLargeDataset(1000) 
                }, 1000).then(result => {
                    assert.ok(result.passesThreshold, 
                             `Data binding time (${Math.round(result.totalTime)}ms) should be within threshold (${result.threshold}ms)`);
                    assert.ok(result.avgBindingTime < 1, 
                             `Average binding time per item (${result.avgBindingTime.toFixed(3)}ms) should be minimal`);
                    
                    done();
                });
            });

            QUnit.test("Should handle frequent model updates efficiently", function(assert) {
                const done = assert.async();
                
                const model = new JSONModel({ 
                    counter: 0,
                    items: generateLargeDataset(100)
                });
                
                const component = new List({
                    headerText: "Counter: {/counter}",
                    items: {
                        path: "/items",
                        template: new StandardListItem({
                            title: "{title}",
                            description: "{description}"
                        })
                    }
                });
                
                component.setModel(model);
                component.placeAt("qunit-fixture");
                
                // Measure update performance
                const startTime = performance.now();
                const updateCount = 100;
                let currentUpdate = 0;
                
                const performUpdate = () => {
                    if (currentUpdate >= updateCount) {
                        const totalTime = performance.now() - startTime;
                        const avgUpdateTime = totalTime / updateCount;
                        
                        assert.ok(avgUpdateTime < 10, 
                                 `Average update time (${avgUpdateTime.toFixed(2)}ms) should be under 10ms`);
                        assert.ok(totalTime < 1000, 
                                 `Total update time (${Math.round(totalTime)}ms) should be under 1 second`);
                        
                        component.destroy();
                        done();
                        return;
                    }
                    
                    model.setProperty("/counter", currentUpdate);
                    currentUpdate++;
                    
                    requestAnimationFrame(performUpdate);
                };
                
                // Start updates after initial render
                component.addEventDelegate({
                    onAfterRendering: () => {
                        setTimeout(performUpdate, 100);
                    }
                });
            });

            QUnit.module("Memory Usage Tests", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                    performanceMonitor.start();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                    performanceMonitor.stop();
                }
            });

            QUnit.test("Should detect memory leaks", function(assert) {
                if (!performance.memory) {
                    assert.ok(true, "Performance.memory API not available - skipping test");
                    return;
                }
                
                const done = assert.async();
                
                const testFunction = () => {
                    return new Promise((resolve) => {
                        const data = { items: generateLargeDataset(100) };
                        createTestComponent(data).then(component => {
                            component.placeAt("qunit-fixture");
                            
                            // Simulate some operations
                            component.getItems().forEach(item => {
                                item.getTitle();
                                item.getDescription();
                            });
                            
                            // Important: Properly destroy component
                            component.destroy();
                            resolve();
                        });
                    });
                };
                
                this.oPerformanceEngine.testMemoryUsage(testFunction, 10).then(result => {
                    if (result.error) {
                        assert.ok(true, "Memory testing not supported");
                        done();
                        return;
                    }
                    
                    assert.ok(!result.hasMemoryLeak, 
                             `Memory increase (${result.memoryIncrease.toFixed(2)}MB) should be within acceptable limits`);
                    assert.ok(result.avgMemoryPerIteration < 1, 
                             `Average memory per iteration (${result.avgMemoryPerIteration.toFixed(2)}MB) should be minimal`);
                    
                    console.log("Memory Usage Test Results:", result);
                    done();
                });
            });

            QUnit.module("Bundle Size and Loading Tests", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                }
            });

            QUnit.test("Should analyze bundle size", function(assert) {
                const done = assert.async();
                
                this.oPerformanceEngine.testBundleSize().then(result => {
                    assert.ok(result.totalSize > 0, "Should detect loaded resources");
                    assert.ok(result.jsSize > 0, "Should detect JavaScript resources");
                    
                    // Log bundle analysis for review
                    console.log("Bundle Analysis:", {
                        totalSize: result.totalSize + " KB",
                        jsSize: result.jsSize + " KB", 
                        cssSize: result.cssSize + " KB",
                        resourceCount: result.totalResourceCount,
                        passesThreshold: result.passesThreshold,
                        largestResources: result.largestResources
                    });
                    
                    // Note: Bundle size threshold may need adjustment based on app requirements
                    if (!result.passesThreshold) {
                        console.warn(`Bundle size (${result.totalSize}KB) exceeds threshold (${result.threshold}KB)`);
                    }
                    
                    done();
                });
            });

            QUnit.module("Core Web Vitals", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                }
            });

            QUnit.test("Should measure Core Web Vitals", function(assert) {
                const done = assert.async();
                
                this.oPerformanceEngine.testCoreWebVitals().then(result => {
                    // Check First Contentful Paint
                    if (result.supported.fcp) {
                        assert.ok(result.values.fcp > 0, "Should measure First Contentful Paint");
                        assert.ok(result.passesThresholds.fcp, 
                                 `FCP (${Math.round(result.values.fcp)}ms) should be within threshold`);
                    }
                    
                    // Check First Input Delay (simulated)
                    if (result.supported.fid) {
                        assert.ok(result.passesThresholds.fid, 
                                 `FID (${Math.round(result.values.fid)}ms) should be within threshold`);
                    }
                    
                    // Check Cumulative Layout Shift
                    if (result.supported.cls) {
                        assert.ok(result.passesThresholds.cls, 
                                 `CLS (${result.values.cls.toFixed(3)}) should be within threshold`);
                    }
                    
                    console.log("Core Web Vitals Results:", result);
                    done();
                });
            });

            QUnit.module("Performance Report Generation", {
                beforeEach: function() {
                    this.oPerformanceEngine = new PerformanceEngine();
                },
                afterEach: function() {
                    this.oPerformanceEngine.destroy();
                }
            });

            QUnit.test("Should generate comprehensive performance report", function(assert) {
                const done = assert.async();
                
                // Run a few tests to populate measurements
                Promise.all([
                    this.oPerformanceEngine.testDataBindingPerformance({ items: generateLargeDataset(100) }),
                    this.oPerformanceEngine.testBundleSize(),
                    this.oPerformanceEngine.testCoreWebVitals()
                ]).then(() => {
                    const report = this.oPerformanceEngine.generatePerformanceReport();
                    
                    assert.ok(report.summary, "Report should contain summary");
                    assert.ok(report.measurements, "Report should contain measurements");
                    assert.ok(report.recommendations, "Report should contain recommendations");
                    assert.ok(typeof report.score === 'number', "Report should contain numeric score");
                    
                    assert.ok(report.summary.totalTests > 0, "Should have performed some tests");
                    assert.ok(report.measurements.length > 0, "Should have recorded measurements");
                    
                    console.log("Performance Report:", {
                        score: report.score,
                        totalTests: report.summary.totalTests,
                        passedTests: report.summary.passedTests,
                        recommendations: report.recommendations.length
                    });
                    
                    // Export report for external analysis if needed
                    window.performanceReport = report;
                    
                    done();
                });
            });

            // Custom assertion for performance
            QUnit.assert.performsBetterThan = function(actualTime, thresholdTime, message) {
                this.pushResult({
                    result: actualTime <= thresholdTime,
                    actual: actualTime,
                    expected: `<= ${thresholdTime}`,
                    message: message || `Performance time (${Math.round(actualTime)}ms) should be within threshold (${thresholdTime}ms)`
                });
            };

            // Performance regression detection
            QUnit.assert.noPerformanceRegression = function(currentTime, baselineTime, tolerance = 0.1, message) {
                const regressionThreshold = baselineTime * (1 + tolerance);
                this.pushResult({
                    result: currentTime <= regressionThreshold,
                    actual: currentTime,
                    expected: `<= ${regressionThreshold}`,
                    message: message || `Performance should not regress by more than ${(tolerance * 100)}% (baseline: ${Math.round(baselineTime)}ms)`
                });
            };

            QUnit.start();
        });
    </script>
</body>
</html>