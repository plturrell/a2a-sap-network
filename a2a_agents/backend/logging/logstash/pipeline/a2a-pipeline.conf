# A2A Network Logstash Pipeline Configuration
# Processes logs from A2A agents with enrichment and routing

input {
  # Beats input from Filebeat
  beats {
    port => 5044
    host => "0.0.0.0"
    type => "filebeat"
  }
  
  # Direct TCP input for applications
  tcp {
    port => 5000
    codec => json_lines
    type => "tcp"
  }
  
  # HTTP input for structured logs
  http {
    port => 8080
    codec => json
    type => "http"
  }
  
  # Syslog input
  syslog {
    port => 5514
    type => "syslog"
  }
}

filter {
  # Common fields for all A2A logs
  mutate {
    add_field => {
      "[@metadata][pipeline]" => "a2a-network"
      "[@metadata][version]" => "2.0.0"
    }
  }

  # Parse container logs from Docker
  if [container][name] {
    mutate {
      add_field => { "source_type" => "container" }
    }
    
    # Extract A2A agent information from container names
    if [container][name] =~ /^a2a-/ {
      grok {
        match => { 
          "[container][name]" => "^a2a-(?<agent_type>.*?)(-(?<instance_id>\d+))?$" 
        }
        add_field => { "service_category" => "a2a_agent" }
      }
    }
  }

  # Parse A2A structured logs
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "a2a"
      add_field => { "log_format" => "json" }
    }
    
    # Extract A2A specific fields
    if [a2a][messageId] {
      mutate {
        add_field => { 
          "a2a_message_id" => "%{[a2a][messageId]}"
          "a2a_context_id" => "%{[a2a][contextId]}"
          "a2a_agent_id" => "%{[a2a][agentId]}"
          "a2a_task_id" => "%{[a2a][taskId]}"
        }
      }
    }
    
    # Extract performance metrics
    if [a2a][performance] {
      mutate {
        add_field => {
          "response_time_ms" => "%{[a2a][performance][responseTime]}"
          "memory_usage_mb" => "%{[a2a][performance][memoryUsage]}"
          "cpu_usage_percent" => "%{[a2a][performance][cpuUsage]}"
        }
      }
      
      ruby {
        code => "
          if event.get('[a2a][performance][responseTime]').to_i > 5000
            event.set('slow_operation', true)
          end
        "
      }
    }
  }

  # Parse standard log levels and timestamps
  grok {
    match => { 
      "message" => "%{TIMESTAMP_ISO8601:log_timestamp} \[%{LOGLEVEL:log_level}\] %{GREEDYDATA:log_message}" 
    }
    overwrite => [ "message" ]
    add_field => { "parsed_timestamp" => true }
  }

  # Parse error stack traces
  if [log_level] == "ERROR" or [log_level] == "error" {
    mutate {
      add_field => { "alert_required" => "true" }
      add_tag => [ "error", "needs_investigation" ]
    }
    
    # Extract error patterns for A2A specific errors
    if [log_message] =~ /Agent.*not.*responding/ {
      mutate {
        add_field => { 
          "error_category" => "agent_communication"
          "severity" => "high" 
        }
      }
    } else if [log_message] =~ /Message.*delivery.*failed/ {
      mutate {
        add_field => { 
          "error_category" => "message_delivery"
          "severity" => "medium" 
        }
      }
    } else if [log_message] =~ /Blockchain.*transaction.*failed/ {
      mutate {
        add_field => { 
          "error_category" => "blockchain_transaction"
          "severity" => "high" 
        }
      }
    }
  }

  # Parse HTTP access logs
  if [message] =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ {
    grok {
      match => { 
        "message" => "%{IPORHOST:client_ip} - - \[%{HTTPDATE:access_timestamp}\] \"%{WORD:http_method} %{URIPATHPARAM:request_path} HTTP/%{NUMBER:http_version}\" %{NUMBER:response_code:int} %{NUMBER:response_size:int}" 
      }
      add_field => { "log_type" => "access_log" }
    }
    
    # Classify HTTP responses
    if [response_code] >= 400 {
      mutate {
        add_tag => [ "http_error" ]
      }
    }
    
    if [response_code] >= 500 {
      mutate {
        add_tag => [ "server_error" ]
        add_field => { "alert_required" => "true" }
      }
    }
  }

  # Enrich with GeoIP for external requests
  if [client_ip] and [client_ip] !~ /^(10\.|172\.(1[6-9]|2\d|3[01])\.|192\.168\.)/ {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }

  # Add correlation IDs for distributed tracing
  if [headers][x-correlation-id] {
    mutate {
      add_field => { "correlation_id" => "%{[headers][x-correlation-id]}" }
    }
  }

  # Parse Kubernetes metadata if present
  if [kubernetes] {
    mutate {
      add_field => {
        "k8s_namespace" => "%{[kubernetes][namespace]}"
        "k8s_pod_name" => "%{[kubernetes][pod][name]}"
        "k8s_container_name" => "%{[kubernetes][container][name]}"
      }
    }
  }

  # Clean up and standardize timestamp
  date {
    match => [ "log_timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss,SSS" ]
    target => "@timestamp"
  }

  # Calculate processing time
  ruby {
    code => "
      event.set('log_processing_time', Time.now.to_f - event.get('@timestamp').to_f)
    "
  }

  # Remove sensitive information
  mutate {
    remove_field => [ 
      "[a2a][password]", 
      "[a2a][apiKey]", 
      "[a2a][token]",
      "[headers][authorization]",
      "[headers][x-api-key]"
    ]
  }
}

output {
  # Route to Elasticsearch with dynamic indices
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    
    # Dynamic index based on log type and date
    index => "a2a-logs-%{+YYYY.MM.dd}"
    
    # Use specific indices for different log types
    if [log_type] == "access_log" {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "a2a-access-logs-%{+YYYY.MM.dd}"
      }
    } else if [service_category] == "a2a_agent" {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "a2a-agent-logs-%{+YYYY.MM.dd}"
      }
    } else if "error" in [tags] {
      elasticsearch {
        hosts => ["elasticsearch:9200"]
        index => "a2a-error-logs-%{+YYYY.MM.dd}"
      }
    }

    # Template for field mappings
    template_name => "a2a-logs"
    template => "/usr/share/logstash/templates/a2a-template.json"
    template_overwrite => true
  }

  # Send alerts for critical errors
  if [alert_required] == "true" {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      content_type => "application/json"
      format => "json"
      mapping => {
        "alerts" => [{
          "labels" => {
            "alertname" => "A2A_Critical_Error"
            "severity" => "%{severity}"
            "service" => "%{agent_type}"
            "instance" => "%{[host][name]}"
          }
          "annotations" => {
            "summary" => "Critical error in A2A system"
            "description" => "%{log_message}"
          }
        }]
      }
    }
  }

  # Debug output for development
  if [@metadata][pipeline] == "debug" {
    stdout { 
      codec => rubydebug {
        metadata => true
      }
    }
  }

  # Metrics output to monitoring system
  if [a2a][performance] {
    statsd {
      host => "statsd"
      port => 8125
      gauge => {
        "a2a.response_time" => "%{response_time_ms}"
        "a2a.memory_usage" => "%{memory_usage_mb}"
        "a2a.cpu_usage" => "%{cpu_usage_percent}"
      }
      increment => [ "a2a.log_processed" ]
    }
  }
}