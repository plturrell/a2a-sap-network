#!/usr/bin/env python3
"""
Comprehensive Security Vulnerability Scanner for A2A Platform
Identifies security issues, vulnerabilities, and compliance gaps
"""

import os
import re
import json
import hashlib
import subprocess
from pathlib import Path
from typing import Dict, List, Any, Set, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime
import base64

@dataclass
class SecurityVulnerability:
    """Security vulnerability finding"""
    severity: str  # "critical", "high", "medium", "low"
    category: str  # "injection", "auth", "crypto", "config", etc.
    description: str
    location: str
    line_number: Optional[int] = None
    recommendation: str = ""
    cve_reference: Optional[str] = None
    confidence: str = "high"  # "high", "medium", "low"

@dataclass 
class SecurityReport:
    """Comprehensive security report"""
    scan_timestamp: str
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    vulnerabilities: List[SecurityVulnerability]
    compliance_status: Dict[str, str]
    recommendations: List[str]

class A2ASecurityScanner:
    def __init__(self):
        self.project_root = Path("/Users/apple/projects/a2a")
        self.vulnerabilities: List[SecurityVulnerability] = []
        
        # Security patterns to detect
        self.security_patterns = {
            # Hardcoded secrets
            'hardcoded_secrets': [
                (r'password\s*=\s*["\'][^"\']+["\']', 'Hardcoded password'),
                (r'api_key\s*=\s*["\'][^"\']+["\']', 'Hardcoded API key'),
                (r'secret\s*=\s*["\'][^"\']+["\']', 'Hardcoded secret'),
                (r'token\s*=\s*["\'][^"\']+["\']', 'Hardcoded token'),
                (r'private_key\s*=\s*["\'][^"\']+["\']', 'Hardcoded private key'),
            ],
            
            # SQL Injection vulnerabilities
            'sql_injection': [
                (r'execute\s*\(\s*["\'].*\%s.*["\']', 'Potential SQL injection via string formatting'),
                (r'query\s*\(\s*["\'].*\+.*["\']', 'Potential SQL injection via string concatenation'),
                (r'SELECT\s+.*\+.*FROM', 'Potential SQL injection in SELECT statement'),
                (r'cursor\.execute\s*\([^)]*\%', 'Potential SQL injection via % formatting'),
            ],
            
            # Command injection
            'command_injection': [
                (r'os\.system\s*\([^)]*\+', 'Command injection via os.system'),
                (r'subprocess\.call\s*\([^)]*\+', 'Command injection via subprocess.call'),
                (r'exec\s*\([^)]*input', 'Code execution with user input'),
                (r'eval\s*\([^)]*input', 'Code evaluation with user input'),
            ],
            
            # Weak cryptography
            'weak_crypto': [
                (r'hashlib\.md5\s*\(', 'Weak hash algorithm (MD5)'),
                (r'hashlib\.sha1\s*\(', 'Weak hash algorithm (SHA1)'),
                (r'random\.random\s*\(', 'Weak random number generation'),
                (r'DES\.|RC4\.|MD5\.', 'Weak encryption algorithm'),
            ],
            
            # Authentication issues
            'auth_issues': [
                (r'auth\s*=\s*False', 'Authentication disabled'),
                (r'verify\s*=\s*False', 'SSL verification disabled'),
                (r'check_hostname\s*=\s*False', 'Hostname verification disabled'),
                (r'session\.get\s*\([^)]*verify=False', 'SSL verification bypassed'),
            ],
            
            # Path traversal
            'path_traversal': [
                (r'open\s*\([^)]*\+.*\)', 'Potential path traversal in file operations'),
                (r'file\s*\([^)]*\+.*\)', 'Potential path traversal in file operations'),
                (r'\.\./', 'Potential directory traversal'),
            ],
            
            # Debug/development code
            'debug_code': [
                (r'print\s*\([^)]*password', 'Password printed in debug output'),
                (r'print\s*\([^)]*secret', 'Secret printed in debug output'),
                (r'debug\s*=\s*True', 'Debug mode enabled'),
                (r'DEBUG\s*=\s*True', 'Debug mode enabled'),
            ]
        }
        
        # File patterns to scan
        self.scan_patterns = [
            "*.py", "*.js", "*.ts", "*.java", "*.php", "*.rb", 
            "*.go", "*.rs", "*.cpp", "*.c", "*.h", "*.sql",
            "*.yaml", "*.yml", "*.json", "*.xml", "*.config",
            "*.env", "*.properties", "*.ini"
        ]
        
        # Skip patterns
        self.skip_patterns = [
            ".git/", "__pycache__/", "node_modules/", ".venv/", 
            "venv/", "build/", "dist/", "target/", "logs/",
            ".pytest_cache/", "coverage/", ".tox/"
        ]

    def scan_hardcoded_secrets(self) -> List[SecurityVulnerability]:
        """Scan for hardcoded secrets and credentials"""
        print("ğŸ” Scanning for hardcoded secrets...")
        
        vulnerabilities = []
        
        for file_path in self._get_scan_files():
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        for pattern, description in self.security_patterns['hardcoded_secrets']:
                            if re.search(pattern, line, re.IGNORECASE):
                                # Skip if it's a placeholder or example
                                if any(placeholder in line.lower() for placeholder in 
                                      ['example', 'placeholder', 'your-', 'todo', 'fixme', 'xxx']):
                                    continue
                                
                                # Skip if it's in a comment
                                if line.strip().startswith('#') or line.strip().startswith('//'):
                                    continue
                                    
                                vulnerabilities.append(SecurityVulnerability(
                                    severity="high",
                                    category="hardcoded_secrets",
                                    description=description,
                                    location=str(file_path.relative_to(self.project_root)),
                                    line_number=line_num,
                                    recommendation="Move secrets to environment variables or secure vault",
                                    confidence="high"
                                ))
            except Exception as e:
                continue
        
        return vulnerabilities

    def scan_injection_vulnerabilities(self) -> List[SecurityVulnerability]:
        """Scan for injection vulnerabilities"""
        print("ğŸ’‰ Scanning for injection vulnerabilities...")
        
        vulnerabilities = []
        
        for file_path in self._get_scan_files():
            if not file_path.suffix.lower() in ['.py', '.js', '.php', '.java']:
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        # SQL injection
                        for pattern, description in self.security_patterns['sql_injection']:
                            if re.search(pattern, line, re.IGNORECASE):
                                vulnerabilities.append(SecurityVulnerability(
                                    severity="high",
                                    category="sql_injection",
                                    description=description,
                                    location=str(file_path.relative_to(self.project_root)),
                                    line_number=line_num,
                                    recommendation="Use parameterized queries or ORM methods",
                                    confidence="medium"
                                ))
                        
                        # Command injection
                        for pattern, description in self.security_patterns['command_injection']:
                            if re.search(pattern, line):
                                vulnerabilities.append(SecurityVulnerability(
                                    severity="critical",
                                    category="command_injection",
                                    description=description,
                                    location=str(file_path.relative_to(self.project_root)),
                                    line_number=line_num,
                                    recommendation="Sanitize user input and use safe alternatives",
                                    confidence="high"
                                ))
            except Exception as e:
                continue
                
        return vulnerabilities

    def scan_crypto_issues(self) -> List[SecurityVulnerability]:
        """Scan for cryptographic issues"""
        print("ğŸ” Scanning for cryptographic vulnerabilities...")
        
        vulnerabilities = []
        
        for file_path in self._get_scan_files():
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        for pattern, description in self.security_patterns['weak_crypto']:
                            if re.search(pattern, line):
                                severity = "high" if any(weak in pattern for weak in ['md5', 'sha1', 'DES', 'RC4']) else "medium"
                                
                                vulnerabilities.append(SecurityVulnerability(
                                    severity=severity,
                                    category="weak_cryptography",
                                    description=description,
                                    location=str(file_path.relative_to(self.project_root)),
                                    line_number=line_num,
                                    recommendation="Use strong cryptographic algorithms (SHA-256, AES-256)",
                                    confidence="high"
                                ))
            except Exception as e:
                continue
                
        return vulnerabilities

    def scan_authentication_issues(self) -> List[SecurityVulnerability]:
        """Scan for authentication and authorization issues"""
        print("ğŸ”“ Scanning for authentication issues...")
        
        vulnerabilities = []
        
        for file_path in self._get_scan_files():
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    lines = content.split('\n')
                    
                    for line_num, line in enumerate(lines, 1):
                        for pattern, description in self.security_patterns['auth_issues']:
                            if re.search(pattern, line, re.IGNORECASE):
                                vulnerabilities.append(SecurityVulnerability(
                                    severity="medium",
                                    category="authentication",
                                    description=description,
                                    location=str(file_path.relative_to(self.project_root)),
                                    line_number=line_num,
                                    recommendation="Enable proper authentication and SSL verification",
                                    confidence="high"
                                ))
            except Exception as e:
                continue
                
        return vulnerabilities

    def scan_file_permissions(self) -> List[SecurityVulnerability]:
        """Scan for insecure file permissions"""
        print("ğŸ“ Scanning file permissions...")
        
        vulnerabilities = []
        
        # Check for overly permissive files
        for file_path in self.project_root.rglob("*"):
            if file_path.is_file():
                try:
                    stat_info = file_path.stat()
                    mode = oct(stat_info.st_mode)[-3:]  # Get last 3 digits
                    
                    # Check for world-writable files
                    if mode.endswith('7') or mode.endswith('6'):
                        vulnerabilities.append(SecurityVulnerability(
                            severity="medium",
                            category="file_permissions",
                            description=f"World-writable file (permissions: {mode})",
                            location=str(file_path.relative_to(self.project_root)),
                            recommendation="Remove world-write permissions",
                            confidence="high"
                        ))
                    
                    # Check for executable config files
                    if (file_path.suffix in ['.conf', '.config', '.env', '.properties'] and 
                        mode[2] in ['1', '3', '5', '7']):
                        vulnerabilities.append(SecurityVulnerability(
                            severity="low",
                            category="file_permissions",
                            description=f"Executable configuration file (permissions: {mode})",
                            location=str(file_path.relative_to(self.project_root)),
                            recommendation="Remove execute permissions from configuration files",
                            confidence="high"
                        ))
                        
                except (OSError, PermissionError):
                    continue
                    
        return vulnerabilities

    def scan_configuration_issues(self) -> List[SecurityVulnerability]:
        """Scan for configuration security issues"""
        print("âš™ï¸ Scanning configuration files...")
        
        vulnerabilities = []
        
        config_patterns = [
            (r'debug.*=.*true', 'Debug mode enabled in configuration', 'medium'),
            (r'ssl.*=.*false', 'SSL disabled in configuration', 'high'),
            (r'secure.*=.*false', 'Security features disabled', 'medium'),
            (r'allow.*=.*\*', 'Wildcard permissions in configuration', 'medium'),
            (r'cors.*origins.*=.*\*', 'CORS wildcard origins allowed', 'medium'),
        ]
        
        for file_path in self.project_root.rglob("*"):
            if file_path.suffix.lower() in ['.conf', '.config', '.ini', '.properties', '.yaml', '.yml', '.json']:
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        lines = content.split('\n')
                        
                        for line_num, line in enumerate(lines, 1):
                            for pattern, description, severity in config_patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    vulnerabilities.append(SecurityVulnerability(
                                        severity=severity,
                                        category="configuration",
                                        description=description,
                                        location=str(file_path.relative_to(self.project_root)),
                                        line_number=line_num,
                                        recommendation="Review and harden configuration settings",
                                        confidence="medium"
                                    ))
                except Exception as e:
                    continue
                    
        return vulnerabilities

    def scan_dependency_vulnerabilities(self) -> List[SecurityVulnerability]:
        """Scan for known vulnerable dependencies"""
        print("ğŸ“¦ Scanning dependencies for vulnerabilities...")
        
        vulnerabilities = []
        
        # Known vulnerable packages (simplified - in production use proper vulnerability DB)
        known_vulns = {
            'requests': ['2.19.0', '2.19.1'],  # Example vulnerable versions
            'flask': ['0.12.0', '0.12.1', '0.12.2'],
            'django': ['1.11.0', '1.11.1'],
            'express': ['4.16.0', '4.16.1'],
        }
        
        # Check Python requirements
        req_files = ['requirements.txt', 'requirements-dev.txt', 'pyproject.toml']
        for req_file in req_files:
            req_path = self.project_root / req_file
            if req_path.exists():
                try:
                    with open(req_path, 'r') as f:
                        for line_num, line in enumerate(f, 1):
                            line = line.strip()
                            if '==' in line:
                                package, version = line.split('==')[:2]
                                package = package.strip()
                                version = version.strip()
                                
                                if package in known_vulns and version in known_vulns[package]:
                                    vulnerabilities.append(SecurityVulnerability(
                                        severity="high",
                                        category="vulnerable_dependency",
                                        description=f"Known vulnerable package: {package} {version}",
                                        location=req_file,
                                        line_number=line_num,
                                        recommendation=f"Update {package} to latest secure version",
                                        confidence="high"
                                    ))
                except Exception as e:
                    continue
        
        # Check Node.js package.json
        package_json = self.project_root / 'package.json'
        if package_json.exists():
            try:
                with open(package_json, 'r') as f:
                    data = json.load(f)
                    dependencies = data.get('dependencies', {})
                    
                    for package, version in dependencies.items():
                        # Remove version prefixes
                        clean_version = version.lstrip('^~>=<')
                        if package in known_vulns and clean_version in known_vulns[package]:
                            vulnerabilities.append(SecurityVulnerability(
                                severity="high",
                                category="vulnerable_dependency",
                                description=f"Known vulnerable Node package: {package} {clean_version}",
                                location="package.json",
                                recommendation=f"Update {package} to latest secure version",
                                confidence="high"
                            ))
            except Exception as e:
                pass
                
        return vulnerabilities

    def check_compliance_status(self) -> Dict[str, str]:
        """Check compliance with security standards"""
        print("ğŸ“‹ Checking compliance status...")
        
        compliance = {
            'OWASP_TOP_10': 'partial',
            'PCI_DSS': 'unknown',
            'GDPR': 'partial',
            'SOX': 'unknown',
            'ISO_27001': 'partial'
        }
        
        # Basic compliance checks
        has_auth = any(v.category == 'authentication' for v in self.vulnerabilities)
        has_crypto = any(v.category == 'weak_cryptography' for v in self.vulnerabilities)
        has_secrets = any(v.category == 'hardcoded_secrets' for v in self.vulnerabilities)
        
        if not has_secrets and not has_crypto:
            compliance['OWASP_TOP_10'] = 'good'
            compliance['ISO_27001'] = 'good'
        elif has_secrets or has_crypto:
            compliance['OWASP_TOP_10'] = 'needs_work'
            compliance['ISO_27001'] = 'needs_work'
            
        return compliance

    def _get_scan_files(self) -> List[Path]:
        """Get list of files to scan"""
        scan_files = []
        
        for pattern in self.scan_patterns:
            for file_path in self.project_root.rglob(pattern):
                if file_path.is_file():
                    # Check if file should be skipped
                    relative_path = str(file_path.relative_to(self.project_root))
                    if not any(skip in relative_path for skip in self.skip_patterns):
                        scan_files.append(file_path)
        
        return scan_files

    def generate_security_fixes(self) -> List[str]:
        """Generate automated security fix recommendations"""
        fixes = []
        
        # Group vulnerabilities by category
        vuln_by_category = {}
        for vuln in self.vulnerabilities:
            if vuln.category not in vuln_by_category:
                vuln_by_category[vuln.category] = []
            vuln_by_category[vuln.category].append(vuln)
        
        # Generate category-specific fixes
        for category, vulns in vuln_by_category.items():
            if category == 'hardcoded_secrets':
                fixes.append(f"Replace {len(vulns)} hardcoded secrets with environment variables")
            elif category == 'weak_cryptography':
                fixes.append(f"Upgrade {len(vulns)} weak cryptographic implementations")
            elif category == 'sql_injection':
                fixes.append(f"Fix {len(vulns)} potential SQL injection vulnerabilities")
            elif category == 'command_injection':
                fixes.append(f"CRITICAL: Fix {len(vulns)} command injection vulnerabilities immediately")
            elif category == 'file_permissions':
                fixes.append(f"Fix {len(vulns)} insecure file permissions")
            elif category == 'configuration':
                fixes.append(f"Harden {len(vulns)} configuration security settings")
            elif category == 'vulnerable_dependency':
                fixes.append(f"Update {len(vulns)} vulnerable dependencies")
        
        return fixes

    def run_full_security_scan(self) -> SecurityReport:
        """Run comprehensive security scan"""
        print("ğŸ›¡ï¸ Starting comprehensive A2A security scan...")
        print("=" * 60)
        
        # Reset vulnerabilities
        self.vulnerabilities = []
        
        # Run all scans
        self.vulnerabilities.extend(self.scan_hardcoded_secrets())
        self.vulnerabilities.extend(self.scan_injection_vulnerabilities())
        self.vulnerabilities.extend(self.scan_crypto_issues())
        self.vulnerabilities.extend(self.scan_authentication_issues())
        self.vulnerabilities.extend(self.scan_file_permissions())
        self.vulnerabilities.extend(self.scan_configuration_issues())
        self.vulnerabilities.extend(self.scan_dependency_vulnerabilities())
        
        # Count by severity
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        for vuln in self.vulnerabilities:
            severity_counts[vuln.severity] += 1
        
        # Check compliance
        compliance_status = self.check_compliance_status()
        
        # Generate fixes
        recommendations = self.generate_security_fixes()
        
        # Create report
        report = SecurityReport(
            scan_timestamp=datetime.now().isoformat(),
            total_vulnerabilities=len(self.vulnerabilities),
            critical_count=severity_counts['critical'],
            high_count=severity_counts['high'],
            medium_count=severity_counts['medium'],
            low_count=severity_counts['low'],
            vulnerabilities=self.vulnerabilities,
            compliance_status=compliance_status,
            recommendations=recommendations
        )
        
        print("\n" + "=" * 60)
        print("ğŸ›¡ï¸ SECURITY SCAN COMPLETE!")
        print("=" * 60)
        print(f"ğŸ“Š Total vulnerabilities found: {report.total_vulnerabilities}")
        print(f"ğŸš¨ Critical: {report.critical_count}")
        print(f"âš ï¸  High: {report.high_count}")
        print(f"âš¡ Medium: {report.medium_count}")
        print(f"â„¹ï¸  Low: {report.low_count}")
        print("=" * 60)
        
        return report

    def export_report(self, report: SecurityReport, format: str = 'json') -> str:
        """Export security report"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if format == 'json':
            filename = f"security_report_{timestamp}.json"
            filepath = self.project_root / filename
            
            # Convert to dict for JSON serialization
            report_dict = asdict(report)
            
            with open(filepath, 'w') as f:
                json.dump(report_dict, f, indent=2, default=str)
                
        elif format == 'markdown':
            filename = f"security_report_{timestamp}.md"
            filepath = self.project_root / filename
            
            md_content = self._generate_markdown_report(report)
            with open(filepath, 'w') as f:
                f.write(md_content)
        
        return str(filepath)

    def _generate_markdown_report(self, report: SecurityReport) -> str:
        """Generate markdown security report"""
        md = []
        md.append("# A2A Platform Security Vulnerability Report")
        md.append(f"**Generated**: {report.scan_timestamp}")
        md.append("")
        
        md.append("## Executive Summary")
        md.append(f"- **Total Vulnerabilities**: {report.total_vulnerabilities}")
        md.append(f"- **Critical**: {report.critical_count}")
        md.append(f"- **High**: {report.high_count}")
        md.append(f"- **Medium**: {report.medium_count}")
        md.append(f"- **Low**: {report.low_count}")
        md.append("")
        
        if report.critical_count > 0:
            md.append("âš ï¸ **URGENT**: Critical vulnerabilities require immediate attention!")
            md.append("")
        
        md.append("## Compliance Status")
        for standard, status in report.compliance_status.items():
            status_icon = "âœ…" if status == "good" else "âš ï¸" if status == "partial" else "âŒ"
            md.append(f"- {standard}: {status_icon} {status}")
        md.append("")
        
        md.append("## Recommendations")
        for i, rec in enumerate(report.recommendations, 1):
            md.append(f"{i}. {rec}")
        md.append("")
        
        md.append("## Detailed Findings")
        
        # Group by severity
        for severity in ['critical', 'high', 'medium', 'low']:
            vulns = [v for v in report.vulnerabilities if v.severity == severity]
            if vulns:
                md.append(f"### {severity.title()} Severity ({len(vulns)} issues)")
                for vuln in vulns:
                    md.append(f"**{vuln.category}**: {vuln.description}")
                    md.append(f"- Location: `{vuln.location}`")
                    if vuln.line_number:
                        md.append(f"- Line: {vuln.line_number}")
                    md.append(f"- Recommendation: {vuln.recommendation}")
                    md.append("")
        
        return "\n".join(md)

def main():
    """Run security vulnerability scan"""
    scanner = A2ASecurityScanner()
    
    # Run scan
    report = scanner.run_full_security_scan()
    
    # Export reports
    json_file = scanner.export_report(report, 'json')
    md_file = scanner.export_report(report, 'markdown')
    
    print(f"ğŸ“„ JSON report saved to: {json_file}")
    print(f"ğŸ“„ Markdown report saved to: {md_file}")
    
    # Print top vulnerabilities
    if report.vulnerabilities:
        print("\nğŸ” Top Security Issues:")
        for vuln in sorted(report.vulnerabilities, 
                          key=lambda v: {'critical': 4, 'high': 3, 'medium': 2, 'low': 1}[v.severity], 
                          reverse=True)[:10]:
            severity_icon = {"critical": "ğŸš¨", "high": "âš ï¸", "medium": "âš¡", "low": "â„¹ï¸"}[vuln.severity]
            print(f"  {severity_icon} {vuln.category}: {vuln.description} ({vuln.location})")
    
    return report

if __name__ == "__main__":
    main()